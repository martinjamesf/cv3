<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Task Manager</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 1rem;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 0.5rem;
      text-align: left;
    }
    th {
      background: #f0f0f0;
    }
    .drag-handle {
      cursor: grab;
      margin-right: 8px;
    }
    .bulk-actions {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .bulk-actions select, .bulk-actions button, .bulk-actions input[type="file"] {
      padding: 0.5rem;
      font-size: 1rem;
    }
    .modal {
      display: none;
      position: fixed;
      background: white;
      border: 1px solid #ccc;
      padding: 1rem;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }
    .overlay {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 5;
    }
    .show {
      display: block;
    }
    .edit-btn {
      float: right;
      margin-bottom: 0.5rem;
    }
  </style>
</head>
<body>

  <h1>Task Manager</h1>
  <button onclick="addTask()">Add Task</button>
  <button onclick="applyWorkflow()">Apply Workflow</button>

  <div class="bulk-actions" id="bulkActions" style="display: none;">
    <select onchange="bulkGroup(this.value)">
      <option disabled selected>Group by</option>
      <option value="Independent">Set Independent</option>
      <option value="Sequential">Set Sequential</option>
      <option value="Parallel">Set Parallel</option>
    </select>

    <select onchange="bulkStatus(this.value)">
      <option disabled selected>Status</option>
      <option value="Not Started">Mark Not Started</option>
      <option value="In Progress">Mark In Progress</option>
      <option value="Completed">Mark Completed</option>
      <option value="Waiting on Someone">Mark Waiting</option>
    </select>

    <button onclick="deleteSelected()">Delete</button>
    <button onclick="exportTasks()">Download JSON</button>
    <input type="file" onchange="importTasks(event)">
  </div>

  <button class="edit-btn" onclick="toggleEditMode()">Edit</button>

  <table id="taskTable">
    <thead>
      <tr>
        <th></th>
        <th>#</th>
        <th>Task Name</th>
        <th>Status</th>
        <th>Group</th>
      </tr>
    </thead>
    <tbody id="taskBody">
      <!-- Tasks will be injected here -->
    </tbody>
  </table>

  <div class="overlay" id="overlay"></div>
  <div class="modal" id="modal">
    <h2>Edit Task</h2>
    <input type="text" id="modalTaskName"/>
    <button onclick="saveModal()">Save</button>
    <button onclick="closeModal()">Close</button>
  </div>

  <script>
    let tasks = JSON.parse(localStorage.getItem('tasks') || '[]');
    let editMode = false;
    let currentEditIndex = null;

    function saveTasks() {
      localStorage.setItem('tasks', JSON.stringify(tasks));
      renderTasks();
    }

    function addTask(name = '', status = 'Not Started', group = 'Independent') {
      tasks.push({ name, status, group });
      saveTasks();
    }

    function applyWorkflow() {
      const steps = [
        "Gather client information",
        "Send client online medical",
        "Complete Application",
        "Send to client for eSign",
        "Submit to underwriting",
        "Delivery policy"
      ];
      steps.forEach(step => addTask(step));
    }

    function deleteSelected() {
      const checkboxes = document.querySelectorAll('.select-row:checked');
      const indexes = Array.from(checkboxes).map(cb => +cb.dataset.index);
      tasks = tasks.filter((_, i) => !indexes.includes(i));
      saveTasks();
    }

    function bulkGroup(value) {
      document.querySelectorAll('.select-row:checked').forEach(cb => {
        tasks[+cb.dataset.index].group = value;
      });
      saveTasks();
    }

    function bulkStatus(value) {
      document.querySelectorAll('.select-row:checked').forEach(cb => {
        tasks[+cb.dataset.index].status = value;
      });
      saveTasks();
    }

    function toggleEditMode() {
      editMode = !editMode;
      document.querySelector('.edit-btn').textContent = editMode ? "Save" : "Edit";
      renderTasks();
    }

    function openModal(index) {
      currentEditIndex = index;
      document.getElementById('modalTaskName').value = tasks[index].name;
      document.getElementById('modal').classList.add('show');
      document.getElementById('overlay').classList.add('show');
    }

    function closeModal() {
      document.getElementById('modal').classList.remove('show');
      document.getElementById('overlay').classList.remove('show');
    }

    function saveModal() {
      tasks[currentEditIndex].name = document.getElementById('modalTaskName').value;
      saveTasks();
      closeModal();
    }

    function renderTasks() {
      const tbody = document.getElementById('taskBody');
      tbody.innerHTML = '';
      document.getElementById('bulkActions').style.display = tasks.some((_, i) =>
        document.querySelector(`.select-row[data-index="${i}"]`)?.checked) ? 'flex' : 'none';

      tasks.forEach((task, i) => {
        const row = document.createElement('tr');

        const selectTd = document.createElement('td');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'select-row';
        checkbox.dataset.index = i;
        checkbox.onclick = () => renderTasks();
        selectTd.innerHTML = 'â˜° ';
        selectTd.appendChild(checkbox);
        row.appendChild(selectTd);

        const numberTd = document.createElement('td');
        numberTd.textContent = task.group === 'Sequential' ? `${i + 1}.1` : `${i + 1}`;
        row.appendChild(numberTd);

        const nameTd = document.createElement('td');
        if (editMode) {
          const input = document.createElement('input');
          input.value = task.name;
          input.onchange = (e) => {
            task.name = e.target.value;
            saveTasks();
          };
          nameTd.appendChild(input);
        } else {
          const link = document.createElement('a');
          link.href = "#";
          link.textContent = task.name;
          link.onclick = () => openModal(i);
          nameTd.appendChild(link);
        }
        row.appendChild(nameTd);

        const statusTd = document.createElement('td');
        if (editMode) {
          const sel = document.createElement('select');
          ["Not Started", "In Progress", "Completed", "Waiting on Someone"].forEach(s => {
            const opt = new Option(s, s, s === task.status, s === task.status);
            sel.appendChild(opt);
          });
          sel.onchange = e => {
            task.status = e.target.value;
            saveTasks();
          };
          statusTd.appendChild(sel);
        } else {
          statusTd.textContent = task.status;
        }
        row.appendChild(statusTd);

        const groupTd = document.createElement('td');
        if (editMode) {
          const sel = document.createElement('select');
          ["Independent", "Sequential", "Parallel"].forEach(s => {
            const opt = new Option(s, s, s === task.group, s === task.group);
            sel.appendChild(opt);
          });
          sel.onchange = e => {
            task.group = e.target.value;
            saveTasks();
          };
          groupTd.appendChild(sel);
        } else {
          groupTd.textContent = task.group;
        }
        row.appendChild(groupTd);

        tbody.appendChild(row);
      });
    }

    function exportTasks() {
      const blob = new Blob([JSON.stringify(tasks)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'tasks.json';
      a.click();
    }

    function importTasks(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          tasks = JSON.parse(e.target.result);
          saveTasks();
        } catch (err) {
          alert("Invalid JSON file");
        }
      };
      reader.readAsText(file);
    }

    renderTasks();
  </script>
</body>
</html>
